## 인덱스  = 색인

WHY? 원하는 것을 쉽게 찾기 위해서

특정기준으로 정렬되어있으면 빠르게 찾을 수 있음

데이터베이스 인덱스는
데이터베이스 테이블에 대한 **검색 성능을 향상**시키는 자료구조로서 **WHERE절을 통해 활용**됨

← **인덱스만을 메모리에 적재하고, 원하는 데이터의 물리적 주소를 찾아 접근하는 방식**

1. 인덱스는 항상 최신의 정렬상태
2. 인덱스도 하나의 데이터베이스 객체 → 10%의 저장공간 차지

# 인덱스 알고리즘

페이지 : 데이터가 저장되는 단위

## Full Tabel Scan

- 순차적으로 접근
- 접근 비용 감소
- 적용 가능한 인덱스가 없는 경우 사용
- 인덱스 처리 범위가 넓은 경우 사용
- 크기가 작은 테이블에 access하는 경우 사용

## B-Tree (Binary Search Tree)

- 트리 높이가 같음
- 자식 노드를 2개이상 가질 수 있음

### 루트페이지 : 자식 페이지의 정보

### 브랜치 페이지 : 자식 페이지의 정보

### 리프 페이지 (!= 데이터 페이지) : 실제 데이터 베이스 페이지

### 페이지 분할

## 인덱스 종류

### 클러스터링 인덱스

실제 데이터와 무리를 이룸

- 실제 데이터 자체가 정렬
- 테이블당 1개만 존재 가능
- 리프 페이지 = 데이터 페이지
- Primary(우선순위) or unique + not null 제약조건 설정

ex. 가다나 인덱스, Primary Key

### 논-클러스터링 인덱스 (= 보조인덱스,

실제 데이터와 다른 무리의 별도의 인덱스

- 실제 데이터 페이지는 그대로
- 별도의 인덱스 페이지 생성 → 추가 공간 필요
- 테이블당 여러 개 존재 가능
- 리프 페이지에 **실제 데이터 페이지의 주소를 담고 있음**
- Unique 제약조건 적용시 자동 생성
- 직접 index todtjdtl

ex. 페이지, Unique Key

### PK 와 UNIQUE KEY 차이

PK : not null + unique

UNIQUE KEY : unique

# 카디널리티 : 그룹내 요소의 개수

어떤 컬럼에 인덱스를 부여해야할까? 

→ **카디널리티개수가 높은 칼럼** = 중복도가 낮은 것

→ WHERE, JOIN, ORDER BY 절에 자주 사용되는 컬럼

→ INSERT UPDATE DELETE가 잘 발생하지 않는 칼럼

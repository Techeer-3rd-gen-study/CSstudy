# 데이터베이스 인덱스

## 인덱스

---

### 인덱스

- 사전적 정의 : 쉽게 찾아볼 수 있도록 일정한 순서에 따라 놓은 목록
- 원하는 값을 빠르게 찾을 수 있다.

### 데이터베이스 인덱스

- 데이터베이스 테이블에 대한 검색 성능을 향상시키는 자료 구조이며, `WHERE` 절 등을 통해 활용

### 데이터베이스 인덱스 특징

- 인덱스는 항상 최신의 정렬상태를 유지
- 인덱스도 하나의 데이터베이스 객체
- 데이터베이스 크기의 약 10% 정도의 저장공간 필요

### 인덱스 알고리즘

- 페이지 : 데이터가 저장되는 단위
- Full Table Scan : 순차적으로 처음부터 데이터 찾음
    - 특징
        - 순차적으로 접근
        - 접근 비용 감소
    - 사용되는 경우
        - 적용 가능한 인덱스가 없는 경우
        - 인덱스 처리 범위가 넓은 경우
        - 크기가 작은 테이블에 엑세스하는 경우

### B-Tree

- 트리 높이가 같음
- 자식 노드를 2개 이상 가질 수 있음
- 기본 데이터베이스 인덱스 구조

### INSERT, UPDATE, DELETE

- `INSERT`
    - 페이지 분할 발생 가능성, 데이터베이스에 좋지 않은 영향
- `UPDATE`
    - WHERE 절로 처리할 대상을 찾기 위한 조회 성능은 향상
- `DELETE`
    - 사용하지 않는 인덱스가 적용되었다면 불필요한 처리량 증가
    - 사용안함 표시로 페이지 낭비 및 인덱스 조각화 심해짐

### 페이지 분할

- 페이지에 새로운 데이터를 추가할 여유공간이 없어 페이지에 변화가 발생
- DB가 느려지고 성능에 영향을 줌

## 인덱스 종류

---

### 클러스터링 인덱스

- 실제 데이터와 같은 무리의 인덱스

### 논 - 클러스터링 인덱스

- 실제 데이터와 다른 무리의 별도의 인덱스

### 클러스터링 인덱스 특징

- 실제 데이터 자체가 정렬
- 테이블당 1개만 존재 가능
- 리프 페이지가 데이터 페이지
- 아래의 제약조건 시 자동 생성
    - primary key
    - unique + not null

### 논 - 클러스터링 인덱스 특징

- 실제 데이터 페이지는 그대로
- 별도의 인덱스 페이지 생성 → 추가 공간 필요
- 테이블당 여러 개 존재
- 리프 페이지에 실제 데이터 페이지 주소 담고 있음
- unique 제약조건 적용 시 자동 생성
- 직접 index 생성 시 논-클러스터링 인덱스 생성

## 카디널리티

---

### 사전적 의미

- 그룹 내 요소의 개수

### 인덱스 적용 기준

- 중복도가 낮은 컬럼(카디널리티가 높은)
- where, join, order by 절에 자주 사용되는 컬럼
- insert, update, delete가 자주 발생하지 않는 컬럼
- 규모가 작지 않은 테이블

## 인덱스 사용시 주의사항

---

- 잘 활용되지 않는 인덱스는 과감히 제거
    - WHERE 절에 사용되더라도 자주 사용해야 가치가 있다.
    - 불필요한 인덱스로 성능저하가 발생할 수 있다.
- 데이터 중복도가 높은 컬럼은 인덱스 효과가 적다.
- 자주 사용되더라도 INSERT, UPDATE, DELETE 가 자주 일어나는지 고려해야 한다.
    - 일반적인 웹 서비스와 같은 온라인 트랜잭션 환경에서 쓰기와 읽기 비율은 2:8 또는 1:9
    - 조금 느린 쓰기를 감수하고 빠른 읽기를 선택하는 것도 하나의 방법

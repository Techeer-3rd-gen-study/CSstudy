# Cookie

: 서버와 클라이언트가 대화하기 위한 수단

- browser와 server와 연결이 됐을때 browser에서 자동적으로 쿠키를 생성하고, response할 때 쿠키를 담아서 보낸다
- 특정 호스트에서 생성된 쿠키는 이후 코든 요청마다 서버로 전송된다
- 요청 header의 set-cookie속성에 정보를 담을 수 있음 → 보안상 우려있음
- 이름, 값, 만료날짜로 구성

# Session

: 서버와 클라이언트의 연결이 활성화된 상태

- 클라이언트가 서버와 통신을 시작하면, 서버는 해당 클라이언트에 대해 유일한 값인 session id를 부여함 → 세션 storage에 세션 정보 저장
- 클라이언트는 이 session id 쿠키를 통해 기억함 → 세션과 쿠키는 이분법적인게 아님
- Client : 어떤 요청을 보낼 때마다 헤더의 cookie에 세션 id를 담아 전송함
- Server : 클라이어트가 보낸 요청의 **cookie에 담긴 세션 id**와 **세션 storage에 담긴 세션 id**를 대조해서 인증 상태를 판단

⇒ 세션과 쿠키는 분리된 개념이 아닌, **세션은 쿠키를 기반**으로 함

- 각 클라이언트마다 유니크한 `세션 객체`가 주어짐. 이 세션 객체를 데이터에 담아 관리할 수도 있음
(세션 객체가 자물쇠로 잠긴 상태면 세션 id가 열쇠인셈)

![Untitled](https://user-images.githubusercontent.com/52391627/202964854-3d5321fe-718e-4b57-a42e-7c5011d11f07.png)
(출처 :https://velog.io/@kingth/서버-인증-방식세션쿠키-토큰 )


세션을 사용하지않고 쿠키만으로 어떤 데이터를 주고받는다 
→ 클라이언트는 이미 모든 데이터를 알고있다는 것

**‘쿠키만으로 인증을 한다’는 것은 서버의 자원을 사용하지 않는다는 것**

→ 즉 클라이언트가 인증 정보를 책임지게됨
  만약 HTTP request가 해커에 의해 탈취당할 경우 사용자의 정보는 클라이언트에 모든 인증정보가 있으니 다 털림 

### Session / Cookie 인증방식을 사용하는 이유 : 서버에 인증의 책임을 전가하기 위해

## Session / Cookie 방식의 장점

1. 세션/쿠키 방식은 기본적으로 **쿠키를 매개**로 인증을 거침
쿠키 : 세션 저장소에 담긴 유저 정보를 얻기 위한 열쇠
→쿠키가 담긴 HTTP요청이 도중에 노출되더라도 쿠키에 담긴 세션 ID는 유의미한 값을 가지고 있지 않음 (쿠키에 있는 세션ID를 변조해도 세션 저장소의 세션ID와 대조할 때 리젝됨)
2. 사용자별로 고유 세션ID를 발급받기때문에 서버는 쿠키값을 받았을 때 일일이 회원정보를 확인할 필요없이 어떤 회원인지 식별 가능 →서버의 자원에 접근하기 용이

## Session / Cookie 방식의 문제점

이미 인증된 사용자의 HTTP요청을 해커가 가로챘다면 그 안의 Cookie도 탈취가능 
→ 해커가 인증된 사용자의 Cookie를 실어 서버에 요청을 보내면, 서버는 인증된 사용잔지 해커인지 구분 불가능

## 해결법

1. HTTPS사용 ← 서버와 클라이언트간의 주고받는 정보를 암호화하기때문에 요청을 탈취해도 정보를 읽을 수 없음
2. 세션에 유효기간을 지정한다. ← 일정시간이 지나면 서버와 클라이언트간의 세션을 끊음
